configfile: "config.yaml"
include: "functions.smk" #Python functions

#Run workflow for single-read (SR) data  
if config["seq_type"] == "SR":
    samples = list(config["sr_samples"].keys())
    rule all:    
        input:
            expand("../results/fastqc/{sample}_fastqc.html", sample=samples), #FastQC and MultiQC reports
            expand("../results/mapped_reads/{sample}.bam", sample=samples), #BWA mapped BAM files
            expand("../results/sorted_reads/{sample}.bam.bai", sample=samples), #Sorted and indexed BAM files
            expand("../results/variant_calls/{sample}.raw.vcf.gz", sample=samples) #Variant call VCF files

#Run workflow for pair-end (PE) data    
elif config["seq_type"] == "PE":
    samples = list(config["pe_samples"].keys())
    rule all:        
        input:
            expand("../results/fastqc/{sample}_2_fastqc.html", sample=samples), #FastQC and MultiQC reports
            expand("../results/mapped_reads/{sample}.bam", sample=samples), #BWA mapped BAM files
            expand("../results/sorted_reads/{sample}.bam.bai", sample=samples), #Sorted and indexed BAM files
            expand("../results/variant_calls/{sample}.raw.vcf.gz", sample=samples) #Variant call VCF files

#Quality check with FastQC before trimming
rule fastqc:
    input:
        get_preprocessed_input_fastqs #Function setup in "functions.smk"
    output:
        #Using expand to create outputs for both reads in pair-end data
        html = expand("../results/fastqc/{sample}_{read}_fastqc.html", sample="{sample}", read=["1", "2"]),
        zip  = expand("../results/fastqc/{sample}_{read}_fastqc.zip",  sample="{sample}", read=["1", "2"])
    threads: 4
    conda:
        "envs/fastqc.yaml"
    log:
        "../results/logs/fastqc/{sample}_fastqc.log"
    shell:
        "(fastqc -t {threads} -o ../results/fastqc/ {input}) > '{log}' 2>&1"

#Trimming with Trim Galore! and FastQC post-trimming
#For Illumina data: Assumes common Illumina adapters
if config["tech"] == "illumina":
    rule trim_galore:
        input:
            get_preprocessed_input_fastqs #Function setup in "functions.smk"
        output:
            r1 = "../results/trimmed_fastq/{sample}_1_val_1.fq.gz",
            r2 = "../results/trimmed_fastq/{sample}_2_val_2.fq.gz"
        threads: 4
        conda:
            "envs/trim_galore.yaml"
        log:
            "../results/logs/fastqc/{sample}_trimming.log"
        shell:
            "(trim_galore --fastqc --paired --gzip --output_dir ../results/trimmed_fastq/ {input}) > '{log}' 2>&1"

elif config["tech"] == "iontorrent":
    adapter = config["adapter"]
    rule trim_galore:
        input:
            get_preprocessed_input_fastqs #Function setup in "functions.smk"
        output:
            "../results/trimmed_fastq/{sample}_trimmed.fq.gz"
        threads: 4
        conda:
            "envs/trim_galore.yaml"
        log:
            "../results/logs/fastqc/{sample}_trimming.log"
        shell:
            "(trim_galore --adapter {adapter} --fastqc --gzip --output_dir ../results/trimmed_fastq/ {input}) > '{log}' 2>&1"

rule multiqc:
    input:
        '../results/fastqc/' #Gathers all FastQC results
    output:
        "../results/fastqc/multiqc_report.html"
    conda:
        "envs/multiqc.yaml"
    log:
        "../results/logs/fastqc/multiqc.log"
    shell:
        "(multiqc {input} -o ../results/fastqc/) > '{log}' 2>&1"

#Mapping with BWA MEM and conversion to BAM with samtools
rule bwa_map:
    input:
        ref="../data/references/hg38.fa",
        fastq = get_bwa_map_input_fastqs
    output:
        "../results/mapped_reads/{sample}.bam"
    params:
        rg=r"@RG\tID:{sample}\tSM:{sample}" #Adding headers to BAM files   
    threads: 8
    conda:
        "envs/bwa.yaml"
    log:
        "../results/logs/bwa_mem/{sample}_mapping.log"
    shell:
        "(bwa mem -R '{params.rg}' -t {threads} {input.ref} {input.fastq} | samtools view -Sb - > {output}) > '{log}' 2>&1"

#BAM sorting with samtools
rule samtools_sort:
    input:
        "../results/mapped_reads/{sample}.bam"
    output:
        "../results/sorted_reads/{sample}.bam"
    conda:
        "envs/bwa.yaml"  
    log:
        "../results/logs/samtools/{sample}_sorting.log"
    shell:
        "(samtools sort -T ../results/sorted_reads/{wildcards.sample} -O bam {input} > {output}) > '{log}' 2>&1"

#BAM indexing with samtools
rule samtools_index:
    input:
        "../results/sorted_reads/{sample}.bam"
    output:
        "../results/sorted_reads/{sample}.bam.bai"
    conda:
        "envs/bwa.yaml" 
    log:
        "../results/logs/samtools/{sample}_indexing.log"
    shell:
        "(samtools index {input}) > '{log}' 2>&1"

#Basic vcf call with bcftools -- Only for WES/WGS data
'''
rule bcftools_call:
    input:
        ref="../data/references/hg38.fa",
        bam=expand("sorted_reads/{sample}.bam", sample=config["pe_samples"]),
        bai=expand("sorted_reads/{sample}.bam.bai", sample=config["pe_samples"])
    output:
        "../results/variant_calls/{sample}.vcf"
    run:
        #Check if pair-end or single-read
        if config["seq_type"] == "PE":
            shell(
                "bcftools mpileup -d 1000000 -f {input.ref} {input.bam} | "
                "bcftools call -mv > {output}")
        else:
            pass  # Skip this rule for single-read data
'''

#Variant calling with GATK Mutect2 - Tumor-only mode
rule gatk_mutect2_tumor_only:
    input:
        ref="../data/references/hg38.fa",
        bam="../results/sorted_reads/{sample}.bam",
        bai="../results/sorted_reads/{sample}.bam.bai",
        bed="../data/bed/OCAPlus.fixed.bed"
    output:
        "../results/variant_calls/{sample}.raw.vcf.gz"
    conda:
        "envs/gatk.yaml"
    log:
        "../results/logs/gatk/{sample}_mutect2.log"
    shell:
        "(gatk Mutect2 -R {input.ref} \
        -I {input.bam} \
        -O {output}) > '{log}' 2>&1"